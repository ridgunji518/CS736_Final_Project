#ifndef SIMPLE_CUDA_MUTEX_EBO_CU#define SIMPLE_CUDA_MUTEX_EBO_CU#include <cuda.h>#ifndef MAX_BACKOFF#define MAX_BACKOFF 512u#endif#ifndef HAS_NANOSLEEP#define HAS_NANOSLEEP 0#endif// ===============================// 创建锁（只记录锁编号）// ===============================inline __host__ cudaError_t cudaMutexCreateSimpleEBO(int *handle, int id){    *handle = id;    return cudaSuccess;}// ===============================// Block-level locking// ===============================inline __device__ void cudaMutexSimpleEBOLock(    const int mutex,    unsigned int *mutexBuf   // 这是全局唯一锁的地址){    __shared__ int done;    __shared__ unsigned int backoff;    const bool isMaster = (threadIdx.x == 0 && threadIdx.y == 0 && threadIdx.z == 0);    if (isMaster) {        done = 0;        backoff = 1;    }    __syncthreads();    while (!done)    {        __syncthreads();        if (isMaster)        {            // CAS 0 → 1 成功代表获得锁            if (atomicCAS(mutexBuf, 0, 1) == 0) {                __threadfence();                done = 1;            } else {                // backoff 等一会#if ((HAS_NANOSLEEP == 1) && (CUDART_VERSION >= 1100))                __nanosleep(backoff);#else                for (int i = 0; i < backoff; ++i) { ; }#endif                // capped exponential backoff                backoff = ((backoff << 1) + 1) & (MAX_BACKOFF - 1);            }        }        __syncthreads();    }}// ===============================// Block-level unlock// ===============================inline __device__ void cudaMutexSimpleEBOUnlock(    const int mutex,    unsigned int *mutexBuf){    __syncthreads();    if (threadIdx.x == 0 && threadIdx.y == 0 && threadIdx.z == 0) {        __threadfence();        atomicExch(mutexBuf, 0);    }    __syncthreads();}#endif