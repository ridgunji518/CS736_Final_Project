#include <cstdio>#include <cstdlib>#include <string>#include <ctime>#include <cuda_runtime.h>// ======================================================// Use your NO-BACKOFF lock// ======================================================#include "cudaMutexSimpleNoBackoff.cuh"#define LETTERS 26// ======================================================// CAS version of atomicAdd for global histogram// ======================================================__device__ void atomicAddCAS(int *addr, int val){    int old = *addr;    int assumed;    do {        assumed = old;        old = atomicCAS(addr, assumed, assumed + val);    } while (assumed != old);}// ======================================================// Kernel - FIXED (NO DEADLOCK)// Only threadIdx.x == 0 uses the lock// ======================================================__global__ void histogram_kernel(    const char *text,    int text_len,    int chunk_size,    int *global_hist,    long long *cs_time,    int mutex,    unsigned int *mutexBuf){    __shared__ int local_hist[LETTERS];    // init shared histogram    for (int i = threadIdx.x; i < LETTERS; i += blockDim.x)        local_hist[i] = 0;    __syncthreads();    // chunk for this block    int start = blockIdx.x * chunk_size;    int end   = min(start + chunk_size, text_len);    // each thread updates shared histogram    for (int i = start + threadIdx.x; i < end; i += blockDim.x)    {        char c = text[i];        if (c >= 'A' && c <= 'Z')            atomicAdd(&local_hist[c - 'A'], 1);        else if (c >= 'a' && c <= 'z')            atomicAdd(&local_hist[c - 'a'], 1);    }    __syncthreads();    // ============ ONLY thread 0 does lock & critical section ============    if (threadIdx.x == 0)    {        long long t0 = clock64();        // ---------- lock (NO BACKOFF) ----------        cudaMutexSimpleNoBackoffLock(mutex, mutexBuf);        // ---------- critical section ----------        for (int i = 0; i < LETTERS; i++)            atomicAddCAS(&global_hist[i], local_hist[i]);        // ---------- unlock ----------        cudaMutexSimpleNoBackoffUnlock(mutex, mutexBuf);        long long t1 = clock64();        cs_time[blockIdx.x] = (t1 - t0);    }}// ======================================================// MAIN// ======================================================int main(){    int N;    printf("Enter the length of random string N: ");    scanf("%d", &N);    if (N <= 0) {        printf("N must be > 0\n");        return 0;    }    // generate random string    std::string text;    text.resize(N);    srand(time(NULL));    for (int i = 0; i < N; i++) {        int r = rand() % 52;        text[i] = (r < 26) ? ('A' + r) : ('a' + (r - 26));    }    // CUDA memory    char *d_text;    cudaMalloc(&d_text, N);    cudaMemcpy(d_text, text.data(), N, cudaMemcpyHostToDevice);    int *d_hist;    cudaMalloc(&d_hist, LETTERS * sizeof(int));    cudaMemset(d_hist, 0, LETTERS * sizeof(int));    unsigned int *d_mutexBuf;    cudaMalloc(&d_mutexBuf, sizeof(unsigned int));    cudaMemset(d_mutexBuf, 0, sizeof(unsigned int));    int mutex;    cudaMutexCreateSimpleNoBackoff(&mutex, 0);    int chunk_size = 1024;    int grid = (N + chunk_size - 1) / chunk_size;    int block = 256;    printf("Launching kernel: grid=%d block=%d\n", grid, block);    long long *d_cs_time;    cudaMalloc(&d_cs_time, grid * sizeof(long long));    // ---- timing ----    cudaEvent_t start, stop;    cudaEventCreate(&start);    cudaEventCreate(&stop);    cudaEventRecord(start);    histogram_kernel<<<grid, block>>>(        d_text, N, chunk_size,        d_hist,        d_cs_time,        mutex, d_mutexBuf);    cudaEventRecord(stop);    cudaEventSynchronize(stop);    float kernel_ms;    cudaEventElapsedTime(&kernel_ms, start, stop);    printf("Kernel time: %.3f ms\n", kernel_ms);    // ---- copy results ----    int h_hist[LETTERS];    cudaMemcpy(h_hist, d_hist, LETTERS * sizeof(int), cudaMemcpyDeviceToHost);    long long *h_cs_time = new long long[grid];    cudaMemcpy(h_cs_time, d_cs_time, grid * sizeof(long long), cudaMemcpyDeviceToHost);     printf("\n===== Letter Histogram =====\n");    for (int i = 0; i < LETTERS; i++)        printf("%c: %d\n", 'A'+i, h_hist[i]);    return 0;}