#ifndef SIMPLE_CUDA_MUTEX_NO_BACKOFF_CUH#define SIMPLE_CUDA_MUTEX_NO_BACKOFF_CUH#include <cuda.h>// 创建锁inline __host__ cudaError_t cudaMutexCreateSimpleNoBackoff(int *handle, int id){    *handle = id;    return cudaSuccess;}// ===== 无 backoff 的 block-level Lock =====inline __device__ void cudaMutexSimpleNoBackoffLock(    const int mutex,    unsigned int *mutexBuf){    __shared__ int done;    const bool isMaster = (threadIdx.x == 0);    if (isMaster) {        done = 0;        __threadfence_block();    }    __syncthreads();    while (!done)    {        __syncthreads();        if (isMaster)        {            // 直接 CAS，没有 backoff，自旋等待            if (atomicCAS(mutexBuf, 0, 1) == 0) {                __threadfence();                done = 1;            }        }        __syncthreads();    }}// ===== 无 backoff 的 block-level Unlock =====inline __device__ void cudaMutexSimpleNoBackoffUnlock(    const int mutex,    unsigned int *mutexBuf){    __syncthreads();    if (threadIdx.x == 0) {        __threadfence();        atomicExch(mutexBuf, 0);    }    __syncthreads();}#endif