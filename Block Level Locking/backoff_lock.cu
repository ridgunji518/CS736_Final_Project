// test_ebo_mutex.cu#include <cstdio>#include <cuda_runtime.h>#include "cudaLocks.h"#include "cudaLocksMutexEBO.cuh"// 用 EBO 锁保护的临界区：所有线程争抢同一把锁，对 counter++。__global__ void kernel_with_EBO_lock(cudaMutex_t mutex,                                     unsigned int *mutexBufferHeads,                                     int NUM_SM,                                     int *shared_counter,                                     int iters_per_thread){    const bool isMasterThread = (threadIdx.x == 0 &&                                 threadIdx.y == 0 &&                                 threadIdx.z == 0);    for (int i = 0; i < iters_per_thread; ++i) {        // 整个 block 调用一次 EBO 锁：        // 只有 master thread 做 atomicCAS，其它线程跟着 __syncthreads 等        cudaMutexEBOLock(mutex, mutexBufferHeads, NUM_SM);        // ===== 临界区：只让 master thread 写全局变量 =====	float a=0;	float b=0;        if (isMasterThread) {            int tmp = *shared_counter;            tmp += 1;            *shared_counter = tmp;		for(int j=0;j<100000;j++){		a=a+0.2;		a=a+0.2;		a=a+0.2;		a=a+0.2;		a=a+0.2;		b=a+0.5;		b=b+0.5;		}		        }        // ===== 临界区结束 =====        cudaMutexEBOUnlock(mutex, mutexBufferHeads, NUM_SM);    }}int main() {    cudaError_t err;    // 1. 查询当前 GPU 的 SM 数量    cudaDeviceProp prop;    int dev = 0;    err = cudaGetDeviceProperties(&prop, dev);    if (err != cudaSuccess) {        printf("cudaGetDeviceProperties failed: %s\n",               cudaGetErrorString(err));        return 1;    }    int NUM_SM = prop.multiProcessorCount;    printf("Device %d: %s, NUM_SM = %d\n",           dev, prop.name, NUM_SM);    // 2. 准备 mutex    const int NUM_MUTEXES = 1;    cudaMutex_t mutex;    // 这里只用 0 号 mutex    cudaMutexCreateEBO(&mutex, 0);    // 为每把锁分配 NUM_SM 个 head slot    unsigned int *d_mutexBufferHeads = nullptr;    err = cudaMalloc(&d_mutexBufferHeads,                     NUM_MUTEXES * NUM_SM * sizeof(unsigned int));    if (err != cudaSuccess) {        printf("cudaMalloc d_mutexBufferHeads failed: %s\n",               cudaGetErrorString(err));        return 1;    }    // 初始化为 0 → 表示都空闲    err = cudaMemset(d_mutexBufferHeads, 0,                     NUM_MUTEXES * NUM_SM * sizeof(unsigned int));    if (err != cudaSuccess) {        printf("cudaMemset d_mutexBufferHeads failed: %s\n",               cudaGetErrorString(err));        return 1;    }    // 3. 共享的 counter    int *d_counter = nullptr;    int h_counter = 0;    err = cudaMalloc(&d_counter, sizeof(int));    if (err != cudaSuccess) {        printf("cudaMalloc d_counter failed: %s\n",               cudaGetErrorString(err));        return 1;    }    err = cudaMemcpy(d_counter, &h_counter,                     sizeof(int), cudaMemcpyHostToDevice);    if (err != cudaSuccess) {        printf("cudaMemcpy H2D counter failed: %s\n",               cudaGetErrorString(err));        return 1;    }    // 4. 配置 kernel 参数（可以后面自己调大）// 4. kernel 配置dim3 block(512);dim3 grid(4096);int iters_per_thread =100000;printf("Launching kernel_with_EBO_lock...\n");// ====== TIMER START ======cudaEvent_t start, stop;cudaEventCreate(&start);cudaEventCreate(&stop);cudaEventRecord(start);// =========================kernel_with_EBO_lock<<<grid, block>>>(mutex,                                      d_mutexBufferHeads,                                      NUM_SM,                                      d_counter,                                      iters_per_thread);// ====== TIMER STOP ======cudaEventRecord(stop);cudaEventSynchronize(stop);float ms = 0.0f;cudaEventElapsedTime(&ms, start, stop);printf("Kernel time (EBO-backoff) = %.3f ms\n", ms);cudaEventDestroy(start);cudaEventDestroy(stop);// =========================    err = cudaDeviceSynchronize();    if (err != cudaSuccess) {        printf("kernel_with_EBO_lock failed: %s\n",               cudaGetErrorString(err));        return 1;    }    // 5. 拷回结果    err = cudaMemcpy(&h_counter, d_counter,                     sizeof(int), cudaMemcpyDeviceToHost);    if (err != cudaSuccess) {        printf("cudaMemcpy D2H counter failed: %s\n",               cudaGetErrorString(err));        return 1;    }    int expected = grid.x * iters_per_thread;printf("Final counter = %d, expected = %d\n", h_counter, expected);    cudaFree(d_counter);    cudaFree(d_mutexBufferHeads);    return 0;}